<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Level Editor</title>
  <style>
    canvas {
      background: #000000;
      display: block;
      margin: 0 auto;
      cursor: crosshair;
      border: 2px solid #ffffff88;
    }
    #toolbar { text-align: center; margin: 10px; user-select: none; }
    button { margin: 5px; padding: 10px; }
    #rageMessage { color: red; text-align: center; font-size: 24px; margin-top: 10px; height: 30px; opacity: 0; transition: opacity 1s ease; }
    #deathCounter { text-align: center; font-size: 28px; font-weight: bold; color: #ff4444; margin-top: 10px; }
    body.shake { animation: shake 0.3s; }
    @keyframes shake {
      0% { transform: translate(0,0); }
      25% { transform: translate(10px,-10px); }
      50% { transform: translate(-10px,10px); }
      75% { transform: translate(10px,10px); }
      100% { transform: translate(0,0); }
    }
    /* Gallery */
    #levelGallery {
      display:none;
      position:fixed;
      top:0; left:0;
      width:100%; height:100%;
      background:#111; color:white;
      overflow:auto; z-index:2000;
      padding:20px;
    }
    .card {
      background:#222;
      padding:10px;
      border:1px solid #fff;
      text-align:center;
      width:220px;
    }
    #galleryList {
      display:flex;
      flex-wrap:wrap;
      gap:20px;
    }
    /* Simple modal style for Save menu */
    .menu {
      display:none;
      position:fixed;
      top:50%; left:50%;
      transform:translate(-50%,-50%);
      background:#222; color:white;
      padding:20px; border:2px solid #fff;
      z-index:1000;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button onclick="setTool('start')">Start Point</button>
    <button onclick="setTool('platform')">Platform</button>
    <button onclick="setTool('fallingPlatform')">Falling Platform</button>
    <button onclick="setTool('spike')">Spike</button>
    <button onclick="setTool('goal')">Goal</button>
    <button onclick="setTool('teleport')">Teleport Hole</button>
    <button onclick="spawnCharacter()">Spawn Character</button>
    <button onclick="openSaveMenu()">Save Level</button>
    <button onclick="openGallery()">Level Gallery</button>
    <button onclick="setTool('eraser')">Eraser</button>
    <span style="color:white; margin-left:20px;">Current tool: <span id="currentTool">start</span></span>
  </div>

  <canvas id="canvas" width="800" height="400"></canvas>
  <div id="rageMessage"></div>
  <div id="deathCounter">Deaths: 0</div>

  <!-- Save Menu -->
  <div id="saveMenu" class="menu">
    <h3>Save Level</h3>
    <input id="levelName" type="text" placeholder="Enter level name" style="width:200px;">
    <br><br>
    <button onclick="confirmSave()">Save</button>
    <button onclick="closeSaveMenu()">Cancel</button>
  </div>

  <!-- Gallery Screen -->
  <div id="levelGallery">
    <h2>Saved Levels</h2>
    <div id="galleryList"></div>
    <br>
    <button onclick="closeGallery()">Back</button>
  </div>

  <script>
    const canvas=document.getElementById("canvas");
    const ctx=canvas.getContext("2d");
    const rageMessage=document.getElementById("rageMessage");
    const deathCounter=document.getElementById("deathCounter");
    const toolbar=document.getElementById("toolbar");

    const GRID_SIZE=20;
    let mode="edit", tool="start", keys={};
    let levels=[], currentLevel=0, deathCount=0, deathTimer=0, teleportCooldown=0;
    let player={x:100,y:100,width:20,height:20,vx:0,vy:0,grounded:false,onPlat:null};
    let platforms=[], spikes=[], goal=null, teleports=[], particles=[];
    let rippleTime=0, rippleWaves=[];
    const editorObjects={start:null,platforms:[],spikes:[],goal:null,teleports:[]};

    function setTool(t){ tool=t; document.getElementById("currentTool").textContent=t; }
    function setToolbarVisibility(){ toolbar.style.display=(mode==="play")?"none":"block"; }

    // Save menu
    function openSaveMenu(){ document.getElementById("saveMenu").style.display="block"; }
    function closeSaveMenu(){ document.getElementById("saveMenu").style.display="none"; }
    function confirmSave(){
      const name=document.getElementById("levelName").value.trim();
      if(!name){ alert("Please enter a name!"); return; }
      localStorage.setItem("level_"+name, JSON.stringify(editorObjects));
      alert("Level '"+name+"' saved!");
      closeSaveMenu();
    }

    // Gallery with previews
    function openGallery(){
      const gallery=document.getElementById("galleryList");
      gallery.innerHTML="";
      const keys=Object.keys(localStorage).filter(k=>k.startsWith("level_"));
      if(keys.length===0){ alert("No saved levels found!"); return; }
      keys.forEach(k=>{
        const level=JSON.parse(localStorage.getItem(k));
        const name=k.replace("level_","");
        // preview canvas
        const previewCanvas=document.createElement("canvas");
        previewCanvas.width=200; previewCanvas.height=100;
        const pctx=previewCanvas.getContext("2d");
        pctx.fillStyle="#0077ff"; pctx.fillRect(0,0,200,100);
        (level.platforms||[]).forEach(p=>{ pctx.fillStyle="gray"; pctx.fillRect(p.x/4,p.y/4,p.width/4,p.height/4); });
        (level.spikes||[]).forEach(s=>{ pctx.fillStyle="red"; pctx.fillRect(s.x/4,s.y/4,s.width/4,s.height/4); });
        if(level.goal){ pctx.fillStyle="green"; pctx.fillRect(level.goal.x/4,level.goal.y/4,level.goal.width/4,level.goal.height/4); }
        if(level.start){ pctx.fillStyle="white"; pctx.fillRect(level.start.x/4,level.start.y/4,20/4,20/4); }

        const card=document.createElement("div");
        card.className="card";
        card.appendChild(previewCanvas);

        const title=document.createElement("div");
        title.textContent=name;
        card.appendChild(title);

        const loadBtn=document.createElement("button");
        loadBtn.textContent="Load";
        loadBtn.onclick=()=>{
          editorObjects.start=level.start;
          editorObjects.goal=level.goal;
          editorObjects.platforms=level.platforms||[];
          editorObjects.spikes=level.spikes||[];
          editorObjects.teleports=level.teleports||[];
          mode="edit"; setToolbarVisibility(); closeGallery(); draw();
        };
        card.appendChild(loadBtn);

        const delBtn=document.createElement("button");
        delBtn.textContent="Delete";
        delBtn.onclick=()=>{ localStorage.removeItem(k); openGallery(); };
        card.appendChild(delBtn);

        gallery.appendChild(card);
      });
      document.getElementById("levelGallery").style.display="block";
    }
    function closeGallery(){ document.getElementById("levelGallery").style.display="none"; }

    // Editor click handler with grid snapping
    canvas.addEventListener("click", e=>{
      if(mode!=="edit") return;
      const rect=canvas.getBoundingClientRect();
      let x=e.clientX-rect.left, y=e.clientY-rect.top;
      x=Math.floor(x/GRID_SIZE)*GRID_SIZE;
      y=Math.floor(y/GRID_SIZE)*GRID_SIZE;

      if(tool==="start") editorObjects.start={x,y};
      if(tool==="platform") editorObjects.platforms.push({x,y,width:100,height:20,type:"normal"});
      if(tool==="fallingPlatform") editorObjects.platforms.push({x,y,width:100,height:20,type:"falling",falling:false});
      if(tool==="spike") editorObjects.spikes.push({x,y,width:20,height:20});
      if(tool==="goal") editorObjects.goal={x,y,width:30,height:30};
      if(tool==="teleport"){ const pairId=Math.floor(editorObjects.teleports.length/2); editorObjects.teleports.push({x,y,width:30,height:30,pairId}); }

      if(tool==="eraser"){
        editorObjects.platforms=editorObjects.platforms.filter(p=>!(x>=p.x&&x<=p.x+p.width&&y>=p.y&&y<=p.y+p.height));
        editorObjects.spikes=editorObjects.spikes.filter(s=>!(x>=s.x&&x<=s.x+s.width&&y>=s.y&&y<=s.y+s.height));
        editorObjects.teleports=editorObjects.teleports.filter(tp=>!(x>=tp.x&&x<=tp.x+tp.width&&y>=tp.y&&y<=tp.y+tp.height));
        if(editorObjects.goal && x>=editorObjects.goal.x && x<=editorObjects.goal.x+editorObjects.goal.width && y>=editorObjects.goal.y && y<=editorObjects.goal.y+editorObjects.goal.height) editorObjects.goal=null;
        if(editorObjects.start && x>=editorObjects.start.x && x<=editorObjects.start.x+20 && y>=editorObjects.start.y && y<=editorObjects.start.y+20) editorObjects.start=null;
      }

      draw();
    });

    function spawnCharacter(){
      if(!editorObjects.start){ alert("Place a start point before spawning!"); return; }
      mode="play"; deathCount=0; setToolbarVisibility();
      const level={
        start:editorObjects.start,
        goal:editorObjects.goal,
        platforms:JSON.parse(JSON.stringify(editorObjects.platforms)),
        spikes:JSON.parse(JSON.stringify(editorObjects.spikes)),
        teleports:JSON.parse(JSON.stringify(editorObjects.teleports))
      };
      levels.push(level); currentLevel=levels.length-1; loadLevel(level);
    }

    function loadLevel(level){
      platforms=JSON.parse(JSON.stringify(level.platforms)).map(p=>({ ...p, lastY:p.y, dy:0 }));
      spikes=JSON.parse(JSON.stringify(level.spikes));
      teleports=JSON.parse(JSON.stringify(level.teleports||[]));
      goal=level.goal;
      if(level.start){ player.x=level.start.x; player.y=level.start.y; } else { player.x=100; player.y=100; }
      player.vx=0; player.vy=0; player.grounded=false; player.onPlat=null;
    }

    // Drawing helpers
    function drawRect(o,c){ ctx.fillStyle=c; ctx.fillRect(o.x,o.y,o.width,o.height); }
    function drawCircle(o,c){ ctx.fillStyle=c; ctx.beginPath(); ctx.arc(o.x+o.width/2,o.y+o.height/2,o.width/2,0,Math.PI*2); ctx.fill(); }
    function drawTriangle(s,c){
      ctx.fillStyle=c;
      ctx.beginPath();
      ctx.moveTo(s.x,s.y+s.height);
      ctx.lineTo(s.x+s.width/2,s.y);
      ctx.lineTo(s.x+s.width,s.y+s.height);
      ctx.closePath();
      ctx.fill();
    }

    function drawGrid(){
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      for(let gx=0; gx<canvas.width; gx+=GRID_SIZE){
        ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,canvas.height); ctx.stroke();
      }
      for(let gy=0; gy<canvas.height; gy+=GRID_SIZE){
        ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(canvas.width,gy); ctx.stroke();
      }
    }

    function drawRipple(tp){
      if(!tp) return;
      const cx=tp.x+tp.width/2, cy=tp.y+tp.height/2;
      if(rippleTime%60===0){
        for(let i=0;i<3;i++){
          rippleWaves.push({x:cx,y:cy,radius:tp.width*0.3+i*6,alpha:0.35-i*0.05});
        }
      }
      rippleWaves.forEach(r=>{
        ctx.beginPath();
        ctx.arc(r.x,r.y,r.radius,0,Math.PI*2);
        ctx.strokeStyle=`rgba(255,255,255,${r.alpha})`;
        ctx.lineWidth=2;
        ctx.stroke();
        r.radius+=0.5;
        r.alpha-=0.004;
      });
      rippleWaves=rippleWaves.filter(r=>r.alpha>0);
    }

    function createExplosion(x,y,color="red"){
      for(let i=0;i<20;i++){
        particles.push({
          x,y,
          vx:(Math.random()-0.5)*6,
          vy:(Math.random()-0.5)*6,
          radius:4+Math.random()*4,
          life:60,
          color
        });
      }
    }

    function updateParticles(){
      particles.forEach(p=>{
        p.x+=p.vx;
        p.y+=p.vy;
        p.radius*=0.95;
        p.life--;
      });
      particles=particles.filter(p=>p.life>0);
    }

    function drawParticles(){
      particles.forEach(p=>{
        ctx.fillStyle=p.color;
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);
        ctx.fill();
      });
    }

    function drawPlatforms(list){ list.forEach(p=>drawRect(p,"gray")); }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(mode==="edit"){
        drawGrid();
        if(editorObjects.start)
          drawCircle({x:editorObjects.start.x,y:editorObjects.start.y,width:20,height:20},"white");
        drawPlatforms(editorObjects.platforms);
        editorObjects.spikes.forEach(s=>drawTriangle(s,"red"));
        if(editorObjects.goal) drawRect(editorObjects.goal,"green");
        editorObjects.teleports.forEach(tp=>drawRipple(tp));
      } else {
        drawCircle(player,"white");
        drawPlatforms(platforms);
        spikes.forEach(s=>drawTriangle(s,"red"));
        if(goal) drawRect(goal,"green");
        teleports.forEach(tp=>drawRipple(tp));
      }
      drawParticles();
    }

    function updateDeathCounter(){ deathCounter.textContent="Deaths: "+deathCount; }

    function updatePlatforms(){
      platforms.forEach(p=>{
        p.lastY=p.y;
        if(p.type==="falling" && p.falling){ p.y+=3.5; }
        p.dy=p.y-p.lastY;
      });
    }

    function updatePlayer(){
      if(mode!=="play") return;

      if(deathTimer>0){
        deathTimer--;
        if(deathTimer===0){ loadLevel(levels[currentLevel]); }
        return;
      }

      if(teleportCooldown>0) teleportCooldown--;

      player.vx=0;
      if(keys["ArrowLeft"]) player.vx=-5;
      if(keys["ArrowRight"]) player.vx=5;

      if(!player.grounded){
        player.vy+=0.6;
        if(player.vy>3.5) player.vy=3.5;
      }

      const prevFeet=player.y+player.height;
      player.x+=player.vx;
      player.y+=player.vy;

      if(player.y>canvas.height){
        deathCount++; deathTimer=60;
        showRage("You fell off the map!");
        createExplosion(player.x+player.width/2,player.y+player.height/2,"red");
        return;
      }

      player.grounded=false;
      player.onPlat=null;
      const currFeet=player.y+player.height;
      let landedPlat=null,minPen=Infinity;

      for(const plat of platforms){
        const withinX=player.x+player.width>plat.x && player.x<plat.x+plat.width;
        if(withinX && player.vy>=0 && prevFeet<=plat.y && currFeet>=plat.y){
          const penetration=currFeet-plat.y;
          if(penetration<minPen){ minPen=penetration; landedPlat=plat; }
        }
      }

      if(landedPlat){
        player.y=landedPlat.y-player.height;
        player.vy=0;
        player.grounded=true;
        player.onPlat=landedPlat;
        if(landedPlat.type==="falling"){ landedPlat.falling=true; }
      }

      if(player.grounded && player.onPlat){
        player.y=player.onPlat.y-player.height;
        player.vy=0;
      }

      // Spikes
      for(const s of spikes){
        if(player.x<s.x+s.width && player.x+player.width>s.x &&
           player.y<s.y+s.height && player.y+player.height>s.y){
          deathCount++; deathTimer=60;
          showRage("You touched a spike!");
          createExplosion(player.x+player.width/2,player.y+player.height/2,"red");
          return;
        }
      }

      // Teleports
      for(const tp of teleports){
        if(teleportCooldown===0 &&
           player.x<tp.x+tp.width && player.x+player.width>tp.x &&
           player.y<tp.y+tp.height && player.y+player.height>tp.y){
          const linked=teleports.find(t=>t.pairId===tp.pairId && t!==tp);
          if(linked){
            player.x=linked.x;
            player.y=linked.y-player.height;
            teleportCooldown=30;
          }
        }
      }

      // Goal
      if(goal &&
         player.x<goal.x+goal.width && player.x+player.width>goal.x &&
         player.y<goal.y+goal.height && player.y+player.height>goal.y){
        showRage("Level complete!");
        deathCount=0;
        loadLevel(levels[currentLevel]);
      }
    }

    function showRage(text){
      rageMessage.textContent = text;
      rageMessage.style.opacity = 1;
      document.body.classList.add("shake");
      setTimeout(()=>{
        rageMessage.style.opacity = 0;
        document.body.classList.remove("shake");
      }, 1000);
    }

    function gameLoop(){
      rippleTime++;
      updatePlatforms();
      updatePlayer();
      updateParticles();
      draw();
      updateDeathCounter();
      requestAnimationFrame(gameLoop);
    }

    document.addEventListener("keydown", e=>{
      keys[e.code] = true;

      if(e.code === "Space" && player.grounded && mode === "play"){
        player.vy = -12;
        player.grounded = false;
        player.onPlat = null;
      }

      if(e.code === "KeyE"){
        mode = "edit";
        setToolbarVisibility();
        draw();
      }
    });

    document.addEventListener("keyup", e=>{
      keys[e.code] = false;
    });

    setToolbarVisibility();
    gameLoop();
  </script>
</body>
</html>

